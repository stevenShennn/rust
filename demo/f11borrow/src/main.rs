fn main() {
    println!("Hello, world!");
}


// 所有权系统允许我们通过“Borrowing”的方式达到这个目的。这个机制非常像其他编程语言中的“读写锁”，
// 即同一时刻，只能拥有一个“写锁”，或只能拥有多个“读锁”，不允许“写锁”和“读锁”在同一时刻同时出现。
// 当然这也是数据读写过程中保障一致性的典型做法。只不过Rust是在编译中完成这个(Borrowing)检查的，
// 而不是在运行时，这也就是为什么其他语言程序在运行过程中，容易出现死锁或者野指针的问题。

//1 Borrowring . 通过&符号完成Borrowing：
//fn main() {
//     let x: Vec<i32> = vec!(1i32, 2, 3);
//     let y = &x;
//     println!("x={:?}, y={:?}", x, y);
// }

//2 . 借用和引用
// 借用与引用是一种相辅相成的关系，若B是对A的引用，也可称之为B借用了A。
// 很相近对吧，但是借用一词本意为要归还。所以在Rust用引用时，一定要注意应该在何处何时正确的“归回”借用/引用。 最后面的“高级”小节会详细举例。


// 3. 规则：
// 同一时刻，最多只有一个可变借用（&mut T），或者2。
// 同一时刻，可有0个或多个不可变借用（&T）但不能有任何可变借用。
// 借用在离开作用域后释放。
// 在可变借用释放前不可访问源变量。


// 4. 可变性：
// 默认不可变引用，&T 本身是不可变借用 和可变借用
// 可变借用 需要数据本身也是可变的
// 可变借用： 需要
