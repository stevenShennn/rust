fn main() {
    let mut a = 1 ;
    let  b = a;
    a = a+1 ;
    println!("b : {}",b);
    println!("a : {}",a)
}

// 所有权：
// 解决变量声明周期的管控
// 1. 绑定： rust不会初始化默认值
// 1.1 ： let a:i32 ; :这个语句只会将一个标识a
// 1.2 ： a =100; 此时会栈内存分配一个i32 ，填充100，并绑定a 与内存关系
// 1.3 ： a就是资源拥有者，owner



// 2. 作用域： {}
//{
//     {
//         let a: i32 = 100;
//     }
//     println!("{}", a);
// }

// 2.1 : 这个语句会报错，a 在这个作用域内才存在，在这个作用域内才能访问
// 2.2 : 离开了作用域后，rust会连同绑定的内存、常量字符串、所有者都一起销毁释放



// 3.move
//{
//     let a: String = String::from("xyz");
//     let b = a;
//     println!("{}", a);
// }

// 3.1: 这个语句会报错 ： 这里b 拥有了xyz的String的资源拥有者，所以，a就会报错，a为nil了
// 3.2: 移动所有权： let a =b


// 4.Copy特性
//     let a: i32 = 100;
//     let b = a;
//     println!("{}", a);
// 4.1 : 这个语句不会报错，因为基础类型都实现了Copy特性，此时a\b都是一个值
// 4.2 ： ab的内存地址不一样


// 5.深拷贝 + 浅拷贝
//{
//     let a: String = String::from("xyz");
//     let b = a.clone();  // <-注意此处的clone
//     println!("{}", a);
// }
// 5.1 深拷贝：就是拷贝对象所有内容，放到一个新的数据结构中




// 6 可变性
//let a = vec![1, 2, 3];  //不可变绑定, a <=> 内存区域A(1,2,3)
// let mut a = a;  //可变绑定， a <=> 内存区域A(1,2,3), 注意此a已非上句a，只是名字一样而已
// a.push(4);
// println!("{:?}", a);  //打印：[1, 2, 3, 4]
// 6.1 ： 可变绑定，内存还是同一块，但是新绑定的a去修改这块内存了，这块内存就是可变了

// 6.2 ：下面则是绑定了abc ，然后又绑定了xyz两块内存
//let mut a: &str = "abc";  //可变绑定, a <=> 内存区域A("abc")
// a = "xyz";    //绑定到另一内存区域, a <=> 内存区域B("xyz")
// println!("{:?}", a);  //打印："xyz"


// 7 高级特性
// pub trait Copy: Clone { }
/*我们从前面的小节了解到，let绑定会发生所有权转移的情况，但ownership转移却因为资源类型是否实现Copy特性而行为不同：
let x: T = something;
let y = x;
类型T没有实现Copy特性：x所有权转移到y。
类型T实现了Copy特性：拷贝x所绑定的资源为新资源，并把新资源的所有权绑定给y，x依然拥有原资源的所有权。*/

// 8. move关键字
//